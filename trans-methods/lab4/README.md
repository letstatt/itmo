# Генератор парсеров

## Выбранные пункты:

* LL(1)-грамматики
* Поддержка наследуемых и синтезируемых атрибутов
* Генерация калькулятора и выполнение второй лабораторной работы

## Синтаксис описания грамматики

Перед описанием грамматики можно ввести дополнительный блок данных,
который будет скопирован в начало файла сгенерированного парсера "как есть",
используя специальную секцию `@header`.

```
@header {
#include <vector>
#include <unordered_set>

using namespace std;
};
```

Грамматика задается набором правил для токенайзера и парсера.
Каждое правило заканчивается точкой с запятой и обязано кодироваться ASCII.
Все пробельные символы в описании грамматики игнорируются. Правило для токена
называется терминалом, а правило для парсера - нетерминалом.

## Терминалы (токены)

Правила разбора для токенайзера описываются названием токена и регулярным выражением.
Токен всегда начинается с большой буквы. Распознавание во входном потоке происходит
по убыванию длины сматченной подстроки, а также в порядке определения правил,
при этом символы переноса строк всегда игнорируются, поэтому токены не должны матчиться по ним.

```
WORD: [a-zA-Z]+;
NUMBER: -? [0-9][0-9]+;
PLUS: '+';
EPS: '';
```

Регулярные выражения включают в себя (в порядке уменьшения приоритета):

```
'.*?' - способ экранирования спецсимволов
[a-zA-Z0-9] - класс символов, ограниченная функциональность
(expr) - группировка
?, +, * - контроль вхождения, относится к предыдущему токену
a | b - альтернатива
```

Токенайзеру можно сказать, что токен необходимо пропускать при токенизации, если после его имени написать восклицательный знак:

```
SPACE!: ' ';
```

Существует зарезервированный терминал EOF, обозначающий конец ввода.
На данный момент исходники сгенерированного токенайзера не предоставляют алгоритм онлайн-токенизации,
поэтому терминал EOF обязательно нужно ставить в конце стартового нетерминала.

## Нетерминалы (правила парсера)

В простом случае, правила для парсера описываются названием и тем, во что они разрешаются.
Разрешение может происходить как в терминалы (см. выше), так и в нетерминалы.
Название нетерминала начинается с маленькой буквы. Если грамматика имеет
левую рекурсию или правое ветвление, генератор парсеров не будет пытаться это исправить
и выдаст ошибку.

```
numbers: NUMBER numbersOpt;

numbersOpt: NUMBER numbersOpt;
numbersOpt: EPS;
```

## Наследуемые, синтезируемые и встраиваемые атрибуты

Существуют еще синтезируемые и наследуемые атрибуты, а также
атрибуты, являющиеся будущими вставками кода в сгенерированный код парсера.
Список наследуемых атрибутов следует указывать в объявлении правила для
парсера через пробел, используя перед названием атрибута знак доллара.
Синтезируемые атрибуты перечисляются так же и там же, но после знака `->`.

Названия синтезируемых и наследуемых атрибутов после доллара
начинаются с маленькой буквы. Атрибуты с встраиваемым кодом
должны начинаться с большой буквы.

Для синтезируемых атрибутов необходимо указывать тип
и возможно указание инициализатора. Для наследуемых атрибутов
указание типа и дефолтного инициализатора не требуется. При этом
их дефолтный тип будет написан как `const T&`.

```
// атрибут num имеет тип int и не имеет инициализатора
number -> $num {int}:
    NUMBER $ParseNumber;

// атрибут sum имеет тип int и инициализируется нулем
sum $log {ostream&} -> $sum {int = 0}:
    number PLUS sum $log $DoSum;
```

Описание атрибутов с встраиваемым кодом необходимо необходимо писать отдельно.
Заметим, что они имеют доступ к токенам/нетерминалам, которые были распарсены ранее,
а также наследуемым и синтезируемым атрибутам.

```
$ParseNumber {
    $num = stoi(_NUMBER.text);
};

$DoSum {
    $sum = _number.$num + _sum.$sum;
    $log << to_string($sum) << std::endl;
};
```

Для создания "локальной переменной" достаточно задать наследуемый атрибут с
указанием типа и инициализатора. Можно также воспользоваться встройкой кода.
Переход в правило с наследуемыми атрибутами с передачей аргументов должен осуществляться так:

```
printSum $log{ostream& = cout}:
    sum $log
```

Циклическая зависимость атрибутов друг от друга не должна быть возможной.
