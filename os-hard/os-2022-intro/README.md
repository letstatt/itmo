# Задание 1. Введение в xv6

> Дедлайн — **27 сентября**.
> 
> К этому моменту необходимо сделать pull request и пройти очное ревью. Если вы не успеете, вы получите меньше баллов за задание.

В этом семестре вы получите шесть домашних заданий. В первой части курса мы будем постепенно дорабатывать и улучшать операционную систему [xv6](https://github.com/mit-pdos/xv6-riscv) — учебную ОС, разрабатываемую с 2006 года в MIT. Для выполнения следующих заданий нам понадобится немного понимать, как работает эта ОС и уметь её собирать.

Наша цель — познакомиться с операционной системой xv6 и подготовить окружение для работы.

> Более подробно разобраться с xv6 поможет книга [R. Cox, F. Kaashoek, R. Morris «xv6: a simple, Unix-like teaching operating system»](https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf) (на английском).
>
> Также, возможно, вам понадобится информация об архитектуре RISC-V, на которой запускается xv6. [Спецификация ISA](https://riscv.org/technical/specifications/) доступна на официальном сайте.

## Часть 1. Инструменты

Мы составили инструкции по установке необходимых инструментов под популярные операционные системы:

* [Установка на Linux](tools-linux.md)
* [Установка на Mac OS](tools-macos.md)
* [Установка на Windows](tools-windows.md)

## Часть 2. Запуск ВМ

Склонируйте этот репозиторий себе на компьютер. Важно не скачать его как ZIP-архив, а именно склонировать.

> Может быть полезно: [Resources to learn Git](https://try.github.io/)

Перейдите в директорию с репозиторием. Для сборки и запуска ОС выполните одну команду:

```
$ make qemu
<...>
xv6 kernel is booting

virtio disk init 0
hart 1 starting
hart 2 starting
init: starting sh
$
```

Вы попали в шелл xv6. Попробуйте выполнить какие-нибудь команды:

```
$ ls
.              1 1 1024
..             1 1 1024
xv6-readme     2 2 1982
xargstest.sh   2 3 93
<...>
$ cat xv6-readme
xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern RISC-V multiprocessor using ANSI C.

<...>
```

Чтобы выйти из QEMU, нажмите `Ctrl-A`, затем `X`.

> Обратите внимание, что при перезапуске лишнего вывода перед запуском намного меньше. Это связано с тем, что перекомпилируются только измененные файлы.
>
> Вы можете выполнить `make clean`, чтобы удалить все артефакты сборки и собрать ОС с нуля.

## Часть 3. Pingpong

> Для решения этого и следующих подзаданий создайте ветку `intro` в вашем репозитории и выполните задание в ней.
> 
> В вашем репозитории должно быть две ветки. Ветка `master` изменяться не должна. В ветке `intro` должны быть только коммиты с вашим решением поверх того, что уже было в `master` при выдаче задания. В репозитории должен быть только один PR с вашим решением.
>
> Похожие требования к оформлению предъявляются и для последующих домашних заданий — название ветки будет указано в условии.
>
> По возможности, разбивайте PR на отдельные коммиты, соответствующие частям вашего задания, и давайте коммитам читаемые имена.
>
> Также мы просим вас посчитать, сколько времени вы потратите на выполнение домашнего задания, и указать количество часов в описании PR. Мы собираем эту информацию для статистики.

Прежде чем перейти к основной части курса, познакомимся подробнее с xv6 и её системными вызовами. Мы попробуем написать немного user-space кода.

Научитесь обмениваться данными между процессами с помощью специальных FIFO-каналов — [Unix pipes](https://en.wikipedia.org/wiki/Pipeline_(Unix)). Реализуйте программу `user/pingpong.c`, которая должна:

* Создать пайп.
* Создать дочерний процесс.
* Отправить сообщение `ping` из родительского процесса в дочерний.
* Прочитать их в дочернем процессе, вывести `<child pid>: got <message>` и отправить сообщение `pong` в ответ.
* Прочитать ответ в родительском процессе, вывести `<parent pid>: got <message>`.

Советы для выполнения задания:

* Вам понадобится несколько системных вызовов — `pipe`, `fork`, `read`, `write`, `getpid`. Воспользуйтесь утилитой `man`, чтобы узнать, что делают эти вызовы и как ими пользоваться — поведение в xv6 не особо отличается от других Unix-подобных операционных систем.
* Вместо привычных вам `stdlib.h` и `stdio.h` доступна местная стандартная библиотека — [`user/ulib.c`](user/ulib.c), а также [`printf.c`](user/printf.c) и [`umalloc.c`](user/umalloc.c). Посмотрите на другие программы в директории [`user/`](user/), чтобы понять, как ей пользоваться.
* Добавьте программу в `UPROGS` в `Makefile`, чтобы она скомпилировалась.
* В программах для xv6 обязательно нужно вызывать `exit(0)` для выхода.

## Часть 4. Dump

В прошлом подзадании мы использовали системные вызовы, например, `pipe` и `fork`. Задача системных вызовов — дать программам из user-space возможность выполнять привилегированные команды.

Реализуем новый системный вызов `dump`. Он будет выводить на экран состояние регистров `s2`—`s12` вызываюшего процесса.

Чтобы системный вызов был доступен из user-space, добавим в файл [`user/user.h`](user/user.h) объявление функции `dump`, как это сделано для других системных вызовов. В файл [`user/usys.pl`](user/usys.pl) добавьте строку `entry("dump")` — он отвечает за генерацию ассемблерных инструкций для совершения системного вызова.

Теперь реализуем сам системный вызов. Для этого добавьте функцию `dump` в файл [`kernel/proc.c`](kernel/proc.c). Текущий процесс можно получить с помощью функции `myproc`. Структура `proc` содержит поле `trapframe`, в котором и находятся значения всех регистров. Избегайте лишней копипасты при выводе регистров. Все регистры в xv6 64-битные, однако в рамках данного задания для каждого регистра вам нужно вывести лишь младшую 32-битную часть.

Наконец, отредактируйте файлы [`kernel/syscall.h`](kernel/syscall.h), [`kernel/sysproc.c`](kernel/sysproc.c) и [`kernel/syscall.c`](kernel/syscall.c) так, чтобы появилась возможность вызвать `dump` из user-space. Посмотрите, как реализованы другие вызовы, и сделайте аналогично.

Осталось собрать xv6. Запустите утилиту [`dumptests`](user/dumptests.c) и сравните фактические значения регистров и результат вашего системного вызова.

* Функцию `dump` нужно также определить заголовочном файле в [`kernel/defs.h`](kernel/defs.h).
* Системный вызов должен возвращать 0 при успешном завершении, и код ошибки в остальных случаях. Наш системный вызов всегда завершается успешно.
* Если при запуске `dumptests` выводится сообщение о том, что системный вызов `dump` не найден, то попробуйте пересобрать xv6 с нуля.

## Часть 5*. Dump2 (+3 балла)

> Это — необязательная часть. Если вы выполните её, то получите бонусные баллы. Помните, что необязательная часть сдаётся только вместе со всем заданием — досдать её отдельно не получится.

Мы бы могли использовать системный вызов `dump`, чтобы написать собственный отладчик. Однако, у него есть два недостатка. Во-первых, он выводит значение регистров на экран, и мы не можем обработать эти значения в user-space. Во-вторых, он позволяет узнать значения регистров только у текущего процесса, что делает невозможным отладку другого процесса. Напишем ещё один системный вызов, чтобы исправить эти недостатки — `dump2`. У этого вызова будет три аргумента:

* `int pid` — номер процесса, для которого запрашивается значение регистра
* `int register_num` — номер регистра, число от 2 до 11
* `uint64 *return_value` — адрес, по которому необходимо вернуть значение

Обратите внимание, что в целях безопасности регистры процесса может смотреть только сам процесс и его родитель.

В этом системном вызове, в отличие от `dump`, вам понадобится корректно обрабатывать и возвращать ошибки:

* Верните `-1`, если вызвавший процесс не имеет прав смотреть требуемый регистр
* Верните `-2`, если процесса с таким идентификатором не существует
* Верните `-3`, если передан некорректный номер регистра
* Верните `-4`, если не удалось записать данные по переданному адресу

Полезные советы:

* Аргументы в системные вызовы передаются немного иначе, нежели в обычные функции. Посмотрите на другие системные вызовы, чтобы понять, как получать аргументы из user-space.
* Вы не можете записать данные по адресу `*return_value` — это виртуальный адрес в user-space, и использовать его в kernel-space невозможно. Вам поможет функция `copyout`.

Запустите [`dump2tests`](user/dump2tests.c). Проверка происходит автоматически.
