# Сериализация

Сериализация - процесс преобразования объекта в массив байт
- Чтобы можно было переслать объект по сети
- Или записать на диск

Десериализация - обратный процесс.

Примеры ser/de - XML, JSON, Protobuf. Первые два используют текстовый формат, имеют тяжелую спецификацию, неэффективно передают числа.

## Protobuf

Эффективный бинарный формат сериализации. Может кодогенерироваться под любимые ЯП.

### Описание структуры

У структуры есть поля:
  - У каждого поля есть название
  - Тип
  - И числовой уникальный идентификатор
  - Уникальность - в пределах одной структуры

```proto
message MyStruct {
    string string_field = 1;
    int32 int_field = 2;
    uint64 uint_field = 3;
}
```

Структуры могут быть вложенными (вложенность произвольная).

### Repeated-поля

Любое поле может быть помечено как `repeated`. Структура будет хранить произвольное количество (от нуля до бесконечности) значений такого поля.

### Сериализация чисел

Числа могут быть до uint64 - это 8 байт. На каждое число отправлять 8 байт - расточительно (вдруг из всего диапазона нам отсылают только первые 2 байта?).

Будем применять varint encoding для неотрицательных чисел, а для чисел со знаком - zig-zag.

### Varint encoding

Если число может быть представлено 7 битами - записываем его как есть.

```
01011011
```

Иначе отбрасываем все незначащие нули и делим число на группы по 7 бит. Всем группам, кроме последней, ставим старший (восьмой) бит = 1. Последней группе ставим старший (восьмой) бит = 0.

Десериализация:
- Читаем байты пока старший бит не 0
- Отбрасываем старшие биты у каждого прочитанного байта
  - Получаем несколько семибайтных групп
- Конкатенируем их

Protobuf хранит группы по 7 байт в порядке little-endian, то есть от младшей группы к старшей.

Varint encoding неэффективен для маленьких по модулю отрицательных чисел, поэтому для signed чисел может использоваться zig-zag.

### Zig-zag encoding

```
0 | 0
1 | 1
2 | -1
3 | 2
4 | -2
5 | 3
...
```

Преимущества:
- Маленькие отрицательные числа кодируются небольшим числом байт

Недостатки:
- to_zigzag(126) = 250
- 2 байта на представление вместо одного

Пользователь может включать и отключать Zigzag encoding.

### Сериализация структур

```id_1 : value_1; id_2 : value_2; ... id_n : value_n```

Формат сериализации: список key-value пар
- Ключ - идентификатор поля
- Значение - сериализованное значение поля

Имена полей в сериализованной записи отсутствуют!
- Без схемы нельзя десериализовать

Идентификатор поля - целое число
- Используем varint encoding

### Сериализация полей

- Целые числа - varint
- Перечисления (enum)  - как целые числа
- Числа с плавающей точкой - как есть
  - Тратим всегда 4 или 8 байт
- Строки - длина в байтах + содержимое
  - Массивы байт так же
  - Структуры сериализуем, потом так же

### Сериализация repeated-полей

```rep_id : value_1; rep_id : value_2; ... rep_id : value_n;```

- Просто повторяем key-value пару для каждого элемента списка.
- Можно чередовать с остальными полями.

### Оптимизации Protobuf

1. Поля, которым не задали значения, не попадают в сериализованное представление. При десериализации число будет нулем, bool будет false и так далее.
2. Идентификаторы полей лучше присваивать самому из тех соображений, что частовстречающиеся поля должны иметь меньший номер, а редкие поля - больший (следует из использования varint encoding для идентификаторов полей)
3. Repeated-поле в связке с его большим идентификатором раздувает размер сериализованного представления. Можно хранить сначала идентификатор, потом длину, а потом значения. Этот формат называется packed repeated fields. Не применяется для строк, структур и массивов байт.

### Обратная совместимость правок схемы

Десериализация сериализованного представления с помощью новой версией схемы (добавили поле/удалили поле, сделали поле repeated/убрали repeated) не должна ломаться.

### Совместимость "в будущее"

Десериализация сериализованного представления с помощью старой версии схемы не должна ломаться.

### Удаление полей из схемы

Пусть в схеме у каждого поля есть идентификатор. Удалить поле вместе с идентификатором нельзя, поскольку если в будущем разработчик добавит новое поле с таким же идентификатором, но другим типом, то все может сломаться.

Правильнее помечать удаляемое поле как reserved, чтобы идентификатор больше никто не пытался занять.

### Смена типов полей

Взаимозаменяемы:
- string <-> bytes (если валидная utf-8 строка)
- message <-> bytes (если валидное сообщение в виде байт)
- int32 <-> int64
- sint32 <-> sint64

Не совместимы:
- int32 и sint32
- int64 и sint64
